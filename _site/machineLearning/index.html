<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Machine Learning &middot; Notes
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/notes/public/css/poole.css">
  <link rel="stylesheet" href="/notes/public/css/syntax.css">
  <link rel="stylesheet" href="/notes/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/notes/public/apple-touch-icon-precomposed.png">
                                 <link rel="shortcut icon" href="/notes/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>

  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/notes/">
          Notes
        </a>
      </h1>
      <p class="lead">An Encyclopedia</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/notes/">Home</a>

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/notes/algorithms/">Algorithms</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/notes/applications/">Applied Engineering</a>
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/notes/dynamics/">Dynamics and Controls</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/notes/fluids/">Fluid Mechanics</a>
          
        
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/notes/math/">Mathematics</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/notes/music/">Music Theory</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/notes/propulsion/">Propulsion</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/notes/references/">References</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/notes/structures/">Structures</a>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      

      <!-- <a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Download</a>
      <a class="sidebar-nav-item" href="">GitHub project</a> 
      <span class="sidebar-nav-item">Currently v2.1.0</span> -->
    </nav>

    <p>&copy; 2021. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Machine Learning</h1>
  Last Updated: <span class="post-date">10 Jul 2021</span>
  <p>At its core, machine learning is a <strong>statistical science</strong>, and like most elements of statistics, a great deal of care must be taken when formatting and analyzing data. They way we chose to quantify abstract topics and/or measure error will have a significant impact on the quality of our result.</p>

<!--more-->

<h2 id="matrices">Matrices</h2>

<p>Before getting started - why do we care about matrices? Well, matrices are how we store data. So before we jump into neural networks, we can begin with techniques from linear algebra to extract data patterns.</p>

<p><strong>Vector</strong> - By default, vectors are columns. The transpose/Hermitian of a vector turns it into a row.</p>

<p><strong>Range/Span</strong> - The set of all linear combinations of each vector.</p>

\[R\left(A\right)={\alpha_1A_1+a_2A_2\ldots+\alpha_kA_k,\ for\ any\ \alpha_i\in F}\]

<p><strong>Nullspace/Kernel (of a matrix A)</strong> - The set of all vectors [x] such that Ax = 0</p>

\[N\left(A\right)={x\in F^n,\ Ax=0}\]

<p><strong>Ortho-complement (of a subspace)</strong> -  The set of all vectors [x] that are orthogonal to all vectors in the subspace V.</p>

\[V^\bot={x,\ x\bot y\ for\ all\ y\in V}\]

<p><strong>Linear Dependence</strong> - A set of vectors are said to linearly dependent if there exist scalars \(\alpha\) not all zero such that:</p>

\[\alpha_1V_1+a_2V_2\ldots+\alpha_kV_k=0\]

<p><strong>Rank</strong> - The rank of a matrix is the is the number of linearly independent rows or columns. It is equal to the dimension of the span of the matrix. The rank cannot be greater than min(m, n) given \(A\in F^{m\times n}\).</p>

<h3 id="summary-of-matrix-properties">Summary of Matrix Properties</h3>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th style="text-align: left">Mathematical Expression</th>
      <th style="text-align: left">Equivalent Statements/Other Properties</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Normal Matrix</td>
      <td style="text-align: left">\(AA^H=A^HA\)</td>
      <td style="text-align: left">[A] is normal if it commutes with its conjugate transpose</td>
    </tr>
    <tr>
      <td> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">[A] is diagonalizable by a unitary matrix</td>
    </tr>
    <tr>
      <td> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">There exists a set of eigenvectors of [A] which form an orthonormal basis for range([A])</td>
    </tr>
    <tr>
      <td> </td>
      <td style="text-align: left">\(|A|^2=tr(A^HA)\)</td>
      <td style="text-align: left">The Frobenius norm can by computed by the eigenvalues</td>
    </tr>
    <tr>
      <td> </td>
      <td style="text-align: left">\(A=Q\Lambda Q^H\)</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td> </td>
      <td style="text-align: left">\(AQ[:,i]=λiQ[:,i]\)</td>
      <td style="text-align: left">[A] can be decomposed into the product of its unitary eigenvector matrices and a diagonal matrix of eigenvalues</td>
    </tr>
    <tr>
      <td>Unitary/Orthogonal Matrix</td>
      <td style="text-align: left">\(AA^H=A^HA=I\)</td>
      <td style="text-align: left">[A] is unitary if it is normal and its product with its conjugate transpose equals the identity matrix</td>
    </tr>
    <tr>
      <td> </td>
      <td style="text-align: left">\(|x|_2=|Ax|_2\)</td>
      <td style="text-align: left">The product of a unitary matrix with a vector does not change the magnitude of the vector.</td>
    </tr>
    <tr>
      <td>Symmetric/Hermitian Matrix</td>
      <td style="text-align: left">\(A=A^T\)</td>
      <td style="text-align: left">[A] is symmetric if it is equal to its conjugate transpose</td>
    </tr>
    <tr>
      <td> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">All symmetric matrices are also normal matrices</td>
    </tr>
    <tr>
      <td> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">Rectangular matrices are never normal matrices</td>
    </tr>
    <tr>
      <td> </td>
      <td style="text-align: left"> </td>
      <td style="text-align: left">The eigenvalues of a symmetric (and thus normal) matrix are always real</td>
    </tr>
    <tr>
      <td>Diagonalizable Matrix</td>
      <td style="text-align: left">\(A=Q\Lambda Q^H\)</td>
      <td style="text-align: left">[A] is diagonalizable if it is similar to a diagonal matrix</td>
    </tr>
  </tbody>
</table>

<h3 id="singular-value-decomposition">Singular Value Decomposition</h3>

<p>The singular value decomposition of a matrix [A] yields the following expression, where  U\in F^{m\times m} is the matrix of left singular vector, V\in F^{n\times n} is the matrix of right singular vectors, and the strictly positive entries of \Sigma\in F^{m\times n} are referred to singular values. The number of nonzero singular values equals the rank of [A]. Both U and V are unitary matrixes.</p>

\[A\in F^{m\times n}=U\Sigma V^H\]

<p>Realizing that in some cases, the rank of A is less than either m or n, leaving a few zero entries along the singular values. These send corresponding vectors in U and V to zero, and thus A can be reassembled with only the vectors of U, V and singular values through (r).</p>

\[A=\ \sum_{i=1}^{r}{\sigma_iu_iv_i^H}\]

<h4 id="additional-properties-of-the-svd">Additional Properties of the SVD</h4>

<table>
  <tbody>
    <tr>
      <td>\(Av_j=\sigma_ju_j\ \ \ \ \ \ if\ j\in\left(1,r\right)\)</td>
    </tr>
    <tr>
      <td>\(Av_j=\sigma_ju_j=0\ \ \ \ \ \ \ \ if\ j\in(r+1,\ n)\)</td>
    </tr>
    <tr>
      <td>\(A^Hu_j=\sigma_jv_j\ \ \ \ \ \ \ \ if\ j\in(1,\ r)\)</td>
    </tr>
    <tr>
      <td>The right singular vectors of AH are the left singular vectors of A and vice-versa</td>
    </tr>
    <tr>
      <td>The dimension of the range of A is equal to the rank of A</td>
    </tr>
    <tr>
      <td>\(u_1,u_2,\ldots u_r\) are orthogonal basis vectors for the range of A</td>
    </tr>
    <tr>
      <td>\(u_{r+1},u_{r+2},\ldots u_m\) are orthogonal basis vectors for the orthocomplement of the range of A</td>
    </tr>
    <tr>
      <td>\(v_{r+1},v_{r+2},\ldots u_n\) are orthogonal basis vectors for the nullspace of A</td>
    </tr>
    <tr>
      <td>\(v_1,v_2,\ldots v_r\) are orthogonal basis vectors for the orthocomplement of the nullspace of A</td>
    </tr>
  </tbody>
</table>

<h3 id="orthogonal-projection-matrix">Orthogonal Projection Matrix</h3>

<p>Consider a set of vectors \(v_1,\ v_2,\ \ldots v_k\) which form an orthonormal basis for the subspace of some range V. The orthogonal projection matrix of the subspace V as well as the orthocomplement of V is formed as:</p>

\[P_v=Q_kQ_k^H\]

\[P_{v^\bot}={I-Q}_kQ_k^H\]

<p>The orthogonal projection matrix when multiplied by a vector finds the projection of that vector onto the subspace and is equal to subtraction of any orthogonal components from the original vector. That is:</p>

\[P_{v^\bot}x=x-P_vx\]

<h3 id="pseudo-inverse-moore-penrose-inverse">Pseudo-Inverse (Moore-Penrose Inverse)</h3>

<p>Note that a non-square matrix cannot be inverted in the traditional sense. However, it is still possible to achieve a partial inverse by using the SVD. We define the pseudo inverse as:</p>

\[A^+=V\Sigma^+U^H\]

\[\Sigma^+=\left[\begin{matrix}\Sigma_{r\times r}&amp;0_{r,\ n-r}\\0_{m\times r,\ r}&amp;0_{m-r,\ n-r}\\\end{matrix}\right]\ \in F^{n\times m}\]

<h3 id="least-squares-regressionordinary-least-squares">Least Squares Regression/Ordinary Least Squares</h3>

<p>Given a problem stated in the following format, it is possible to find an exact solution.</p>

\[x_{LS}=argmin\|Ax-b\|_2^2\]

\[x_{LS}=A^+b\]

<p>Thus, we may be generally motivated to format our problems in the above format, such that a solution can be easily solved using the pseudo-inverse. Consider a dataset of inputs and corresponding outputs, denoted as t and b.</p>

<p>Our approximation function we would like to take the form:</p>

\[b_j=c_1+c_2t_j+c_3t_j^2+ \ldots α_1cos(t_j)+β_1sin(t_j)+α_2cos(t_j)+β_2sin(t_j)+ \ldots\]

<p>This can be represented in a linear format by defining the following sets of A and x matrices.</p>

\[x=\ \left[c_1,\ c_2,c_3,\ldots,\ \alpha_1,\beta_1,\alpha_2,\beta_2,\ \ldots\right]^T\]

\[A_j=[1,\ t_j,\ t_j^2, \ldots,\cos(t_j),\sin(t_j),\cos(t_j),\sin(t_j)]\]

<p>Thus, the dot product of x with Aj should yield Equation 1. Repeating the above for every data point will yield a full matrix for A. The coefficients for our model equation which best fit the data can be found now using least squares regression.</p>

<h3 id="regularized-least-squares">Regularized Least Squares</h3>

<p>Consider for a moment, a constrained least squares problem:</p>

\[x_{LS}=argmin\|Ax-b\|_2^2\]

\[\|Dx\|_2&lt;τ\]

<p>As we did in optimization, we can include the constraint, as something that should be included in the weighting of the objective function.</p>

\[x_{LS}=argmin\|Ax-b\|_2^2+λ^2\|Dx\|_2^2\]

<p>We can be reformed into our classic least squares problem format by defining the following sets of matrices:</p>

\[\widetilde{A}=\left[\begin{matrix}A\\\lambda D\\\end{matrix}\right],\ \widetilde{b}=\left[\begin{matrix}b\\0\\\end{matrix}\right]\]

\[x_{LS}=argmin\|Ax-b\|_2^2\]

<h3 id="first-difference-matrix">First Difference Matrix</h3>

<p>The first difference matrix when multiplied by a vector yields the elementwise gradients (taking the spacing/index to be the x displacement).</p>

\[D=\ \left[\begin{matrix}-1&amp;1&amp;0&amp;0&amp;0\\0&amp;-1&amp;\cdots&amp;0&amp;0\\0&amp;\vdots&amp;\ddots&amp;\vdots&amp;0\\0&amp;0&amp;\cdots&amp;-1&amp;1\\1&amp;0&amp;0&amp;0&amp;-1\\\end{matrix}\right]\]

<h3 id="trace-of-a-matrix">Trace of a Matrix</h3>

<p>The trace of a matrix is defined as the sum of values down the primary diagonal. The trace is invariant under cyclic permutation:</p>

\[tr\left(AB\right)=tr\left(BA\right)\]

\[tr\left(A+B\right)=tr\left(A\right)+tr\left(B\right)\]

<h3 id="frobenius-norm">Frobenius Norm</h3>

<p>The Frobenius norm of a matrix is the root of the sum of the square of all values. The frobenius norm is also equal to the square root of the trace, and the sum of square of singular values of A.</p>

\[\|A\|_F = a_{ij}^2\]

\[\|A\|_F^2=tr(AA^H)=tr(A^HA)=σ_i^2\]

<h3 id="principal-component-analysis">Principal Component Analysis</h3>

<p>Consider a matrix whose columns represent different items in a dataset, and whose rows represent different parameters for each data item (i.e. x, y, z, coordinates). Principal Component Analysis, or PCA, finds an orthonormal basis of directions which best fit the data. These lines minimize the average squared distance of each point to the line. This orthonormal basis are also the left singular vectors obtained through SVD.</p>

<p>The first principal component of a matrix A, associated with the first eigenvector/left singular vector of the eigen decomposition and SVD, can be found as the vector which maximizes the second norm of the product of A with x.</p>

\[u_1=\ argmax\|Ax\|^2)\]

<p>The next largest principal component can be found by projecting A into the null space formed from the previously found vectors and repeating the previous calculation. (We are finding the next line of best fit that is orthonormal to any previously found lines).</p>

<h3 id="independent-component-analysis">Independent Component Analysis</h3>

<p>ICA decomposes a signal into independent (non-correlated) non-Gaussian signals. When sources are statistically independent, ICA works very well in separating the two. ICA methods tend to breakdown when there is similarity in the signal, leading to correlation. To do this, ICA identifies directions that maximize absolute kurtosis. Mathematically, this is:</p>

\[x=\ argmax(|k_4(x^TA)|)\]

<p>Where Kurtosis, or fourth central cumulant, is defined as:</p>

\[k_4(y^T)=\frac{1}{n}\sum y_i^4- 3(\frac{1}{n} \sum y_i^2)^2\]

<p>And in addition, subject to a spherical constraint on the x input (i.e., two norm of x is equal to 1).</p>

\[\|x\|_2^2=1\]

<h2 id="machine-learning-algorithms">Machine Learning Algorithms</h2>

<p>Now we can finally get to more modern approaches to machine learning. Current methods fall into three main categories:</p>

<ol>
  <li>Supervised Learning</li>
  <li>Unsurpervised Learning</li>
  <li>Reinforcement Learning</li>
</ol>

<h3 id="k-means-clustering">K-Means Clustering</h3>

<p>Minimizes the intra-cluster variance. The strength of clustering algorithms lies in the fact that it is an unsupervised learning method, i.e., data does not have to come pre-labeled. The process goes:</p>

<ol>
  <li>Propose N cluster centers.</li>
  <li>Assign every pixel to the closest cluster center.</li>
  <li>Calculate new cluster centers using the average of assigned pixels.</li>
  <li>Repeat until centers have stabilized.</li>
</ol>

<p>For data classification, there typically needs to be as many dimensions as independent features (N) we’d like to distinguish. This means that for a task like image classification, we’ll need to find a way to transform a 2D image into a single point in 2D dimensional space.</p>

<h3 id="neural-networks-and-deep-nets">Neural Networks and Deep Nets</h3>

<p>Networks are function approximators. Each node consists of any number of inputs and any number of outputs, but is itself a simple activation function (relu, sigmoid, tangent, etc.) These functions generally produce an output in the range of 0 to 1 or -1 to 1. For each node, there are a series of weights and offsets to be calculated/tuned by the learning process.</p>

<p><img src="../images/dnn.png" alt="deep neural net" class="center-image" /></p>

<p>The benefit of Deep nets is that they can separate non-linear shapes, at the downside of long computation times and unreliable convergence of results. Results depend a lot on how error is measured, the function of each node, etc.</p>

<h3 id="receiver-operator-characteristic-curve">Receiver Operator Characteristic Curve</h3>

<p>The R.O.C plots the probability of correct classification vs the probability of false positive. In an ideal case, the area under the curve will be equal to 1. A random guesser achieves a straight line on this plot, so a classifier needs to beat this result. Placement along the curve is also important, and changes depending on the application.</p>

<p><img src="../images/roc.png" alt="roc curve" class="center-image" /></p>

<h3 id="procrustes-analysis">Procrustes Analysis</h3>

<p>A method for statistical analysis of shape distributions. An orthogonal Procrustes problem is one that finds the optimal rotation, translation, and/or reflection which aligns two shapes.</p>

<h3 id="minimum-dimensions">Minimum Dimensions</h3>

<p>If I told you that there were 4 distinct points, and gave you the distance between every pair, you could determine the minimum dimensional space required to properly map these points. For instance, if all 6 distances are the same, there is no way to position these 4 points in a plane that makes this true. Instead, they must be arranged as a regular tetrahedron in 3D space.</p>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
          
          <h3>
            <a href="/notes/pathPlanning/">
              Path Planning
              <small>25 Aug 2021</small>
            </a>
          </h3>
          
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
          
          <h3>
            <a href="/notes/trajoptimization/">
              Trajectory Optimization
              <small>11 Aug 2021</small>
            </a>
          </h3>
          
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
          
          <h3>
            <a href="/notes/howTomachineLearning/">
              How to Think About Machine Learning
              <small>10 Aug 2021</small>
            </a>
          </h3>
          
        
      </li>
    
      <li>
        
          
          <h3>
            <a href="/notes/vision/">
              Machine Vision
              <small>26 Jul 2021</small>
            </a>
          </h3>
          
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
          
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
          
          <h3>
            <a href="/notes/optimization/">
              Optimization Fundamentals
              <small>10 Jun 2021</small>
            </a>
          </h3>
          
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
      <li>
        
      </li>
    
  </ul>
</div>

    </div>

  </body>
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Machine Learning | Notes</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Machine Learning" />
<meta name="author" content="David Lu" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="At its core, machine learning is a statistical science, and like most elements of statistics, a great deal of care must be taken when formatting and analyzing data. They way we chose to quantify abstract topics and/or measure error will have a significant impact on the quality of our result." />
<meta property="og:description" content="At its core, machine learning is a statistical science, and like most elements of statistics, a great deal of care must be taken when formatting and analyzing data. They way we chose to quantify abstract topics and/or measure error will have a significant impact on the quality of our result." />
<link rel="canonical" href="https://ludavid15.github.io//notes/machineLearning/" />
<meta property="og:url" content="https://ludavid15.github.io//notes/machineLearning/" />
<meta property="og:site_name" content="Notes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-10T00:00:00-07:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Machine Learning" />
<script type="application/ld+json">
{"headline":"Machine Learning","dateModified":"2021-07-10T00:00:00-07:00","description":"At its core, machine learning is a statistical science, and like most elements of statistics, a great deal of care must be taken when formatting and analyzing data. They way we chose to quantify abstract topics and/or measure error will have a significant impact on the quality of our result.","datePublished":"2021-07-10T00:00:00-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ludavid15.github.io//notes/machineLearning/"},"url":"https://ludavid15.github.io//notes/machineLearning/","author":{"@type":"Person","name":"David Lu"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  
</html>
