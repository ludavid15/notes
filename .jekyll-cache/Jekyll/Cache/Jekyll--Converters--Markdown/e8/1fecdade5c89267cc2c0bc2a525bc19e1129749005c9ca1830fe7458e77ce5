I"ï&<p>With better computers, engineers have increasingly turned to model based systems engineering, or MBSE as a solution to the engineering process. After all, things like CAD, CFD, and FEM have enabled us to model complex physics, so why not model a project?</p>

<!--more-->

<h3 id="background">Background</h3>

<p>Before jumping into MBSE, I want to preface by saying that the key to understanding MBSE is to first understand databases. Because most of what it boils down to is a relational or graphical database. Just like how knowing Micrsoft Word doesn‚Äôt make you a great writer, the tools of MBSE don‚Äôt make you a great systems engineer if you don‚Äôt have a solid understanding of <em>data</em>.</p>

<h3 id="why-mbse">Why MBSE?</h3>

<p>The goal of model based systems engineering is to improve upon two things that happen very slowly with traditional requirements documents:</p>

<ol>
  <li>A way to track the design baseline.</li>
  <li>Once a change is made, an easy way to explore how it impacts other systems.</li>
</ol>

<p>The primary advantage of using a model is to quickly see connections while keeping a single point of truth. For instance, if the total mass of your spacecraft is an important parameter, everything which references that number can point directly to that parameter. This way, when that parameter gets updated (hopefully in real time), its effect becomes instantly tangible.</p>

<p>So that‚Äôs the first important concept of MBSE - this idea of the model as a series of connections between parameters. The second concept is <em>visualization</em>, or how humans actually interface with the model. So far, a series of variables and their connections is easily achievable with a database, or even through lines of code, but neither of these are very accessible to a person. Instead we map the model to visualizations so we can have something useful for our human designers. Operations can be still be shown as flowcharts, hardware can still be shown as block diagrams, and of course we can still fall back on tables and matrices where it makes sense (like with data). The key is that each diagram is not static, but is a connected view <em>into</em> the model.</p>

<h2 id="the-model">The Model</h2>

<p>What aspects of a system can we model? Here‚Äôs a list.</p>

<ol>
  <li>Physical Configuration</li>
  <li>Function/Behavior</li>
  <li>Interactions/Data</li>
  <li>Heirarchies/Definitions</li>
</ol>

<h4 id="physical-configuration">Physical Configuration</h4>

<p>Fairly straightfoward, we need to track the hardware, physical connectors, and physical properties (shape, weight, thermal resistence, etc.). If our project was a sentence, the physical configuration would be the nouns.</p>

<h4 id="functionbehavior">Function/Behavior</h4>

<p>Verbs. Things that happen. You could say that function is the first thing we choose. Hardware is designed to meet a function, not the other way around.</p>

<blockquote>
  <p>Technically this isn‚Äôt always true. When a heritage (proven) piece of hardware is selected, its function is already defined, and then engineers build the rest of the system around it.</p>
</blockquote>

<p>Functions could be high level, like ‚Äúlaunch satellite‚Äù, or low level like ‚Äúdetect separation from launch vehicle‚Äù.</p>

<h4 id="interactions">Interactions</h4>

<p>Interactions can be very abstract, but are also very important. A function might include an interaction, (i.e. a satellite interacts with a ground station by sending telemetry), but a physical configuration might also include an interaction (i.e. the baseplate on a satellite draws heat away from the electronics).</p>

<p>And inherent to interactions is data and information. What information is tranferred? How is information formatted? Where does information go?</p>

<h4 id="definitions">Definitions</h4>

<p>Definitions explain the words we create to group stuff together. If many pieces of hardware work together to provide telemetry, we might designate a ‚Äútelemetry subsystem‚Äù. These abstractions are an important part of communicating complex ideas, but can also get messy. Definitions are applicable to any of the three prior groupings: hardware, functions, and interactions.</p>

<h3 id="dodaf">DoDAF</h3>

<p>The Department of Defense Architecture Framework is an effort to generalize how we explain complex systems. Before getting into what DodAF is, let‚Äôs be clear that DoDAF is not necessarily model based systems engineering. DoDAF only defines a set of ‚Äúviewpoints‚Äù, with each viewpoint showing a different aspect of the system. For example, systems viewpoint 4 (SV4) shows functional flow diagrams, while SV1‚Äôs show a high level overview of the physical elements.</p>

<p>Consider an analogy - in CAD, we build 3D shapes. When we try to represent them on a 2D screen, we must choose a viewing angle and projection, but there are likely some standard views that everyone expects. Maybe a cross section to show the internal structure, or a profile view if it‚Äôs a flat plate. DoDAF (and in fact any system diagram) follows the same idea.</p>

<table>
  <thead>
    <tr>
      <th>DoDAF Views</th>
      <th>Explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SV-1</td>
      <td>High level hardware overview</td>
    </tr>
    <tr>
      <td>SV-2</td>
      <td>Detailed hardware overview</td>
    </tr>
    <tr>
      <td>SV-4</td>
      <td>Functional flow diagram</td>
    </tr>
    <tr>
      <td>SV-6</td>
      <td>Resource flow matrix</td>
    </tr>
    <tr>
      <td>SV-10b</td>
      <td>States and Modes transitions</td>
    </tr>
    <tr>
      <td>SV-10c</td>
      <td>Sequence Diagrams</td>
    </tr>
    <tr>
      <td>DIV-1</td>
      <td>Conceptual Data Model</td>
    </tr>
    <tr>
      <td>DIV-2</td>
      <td>Logical Data Model</td>
    </tr>
    <tr>
      <td>DIV-3</td>
      <td>Physical Data Model</td>
    </tr>
  </tbody>
</table>

<h3 id="sv-4">SV-4</h3>

<p>This is the functional viewpoint. In contrast to an SV-10c, an SV-4 is the functional model of your hardware, and NOT necessarily your order of operations. You can think of these a bit like a user story.</p>

<p>In an SV-4, we can either state a heirarchy, (A consists of B, C, D), or we can show it using a flow chart (B, C, and D interact to accomplish A). The first version is known as an SV-4a, and the latter, more complex version is called an SV-4b.</p>

<h3 id="sv-6">SV-6</h3>

<p>This is a table of all your producing and consuming functions (and by extension, the performer of that function) for each resource. In a perfectly connected model, these resource interactions should appear on your functional diagrams (SV-4), physical diagrams (SV-1 and SV-2) and your data diagrams (DIV).</p>

<h3 id="sv-10c">SV-10c</h3>

<p>This is a sequence diagram. In contrast to the SV-4, an SV-10c is not primarily to meant to show the structure of your functions and hardware performers. Instead, an SV-10c tends to be a more explicit (and better) representation of your order of operations. An SV-10c also places greater emphasis on the <em>messages</em> and ownership of an operation. For instance, will you provide me an update, or am I responsible for reaching out and asking for it? As such, SV-10c diagrams are great for modeling detailed behaviors.</p>

<h3 id="div">DIV</h3>

<p>The Data information viewpoint breaks down the heirarchy of data. Like functions, we can think of data both in the abstract, or by implementation. For instance, the attitude of a spacecraft is abstract (DIV-1). A set of quaternions stored into memory is an implementation (DIV-2). Whether those quaternions are stored with any identifying bit headers, or in little or big Endian is physical (DIV-3).</p>

<blockquote>
  <p>CAMEO gives us many tools for representing data. Exchange Elements are the default unit, and can be further refined with Signals. For instance, an exchange element might be created called ‚ÄúPower Command‚Äù, which refines into two signals ‚ÄúPower On‚Äù and ‚ÄúPower Off‚Äù.</p>
</blockquote>

<h3 id="relationships">Relationships</h3>

<p>A key element of systems modeling is the <em>relationship</em> between two elements. Here are a few, presented in no particular order:</p>

<h3 id="composition">Composition</h3>

<p>A composition relationship is a strong relationship, meaning ‚Äúis a part of‚Äù. Usually, this means that the child cannot exist independently of the parent. This is akin to defining a non-optional property. For example in a database, each data entry probably needs a key or index. However, the key/index does not exist conceptually without belonging to a data entry (i.e. if there exists a key, the existence of that key implies that there must exist a data entry).</p>

<h3 id="aggregation">Aggregation</h3>

<p>An aggregration is also a strong relationship, meaning something like ‚Äúis made up of‚Äù or ‚Äúincludes‚Äù. In contrast to a composition, the child <em>can</em> exist independently of the parent. Usually this is used to indicate that the parent is not the sole container of the child property. I think of this like a foreign key in a relational database.</p>

<h3 id="generalization">Generalization</h3>

<p>A generalization is a weak relationship, meaning ‚Äúis a type of‚Äù. For example, a camry and a civic are both types of cars. Element which are specializations of a generalization will <em>inherit</em> the properties of the generalization. If all cars have 4 wheels, then a camry and a civic will also have 4 wheels.</p>

<h3 id="association">Association</h3>

<p>An association is the weakest type of relationship. It simply means ‚Äúrelated to‚Äù. There is no sharing of properties and doesn‚Äôt give you much in the way of definition either. I often use these to capture elements which interface with one another, but are otherwise separate.</p>

:ET